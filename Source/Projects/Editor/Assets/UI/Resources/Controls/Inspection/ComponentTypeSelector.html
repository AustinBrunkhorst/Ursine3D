<link rel="import" href="../../LIB/Polymer/polymer.html">
<link rel="import" href="../TextInput.html">

<dom-module id="x-component-type-inspector">
    <link rel="import" type="css" href="../../Style/Controls/Inspection/ComponentTypeSelector.css">
    <template>
        <div id="header">
            <input is="x-text-input" id="filter" placeholder="Filter By Name..." />
            <div id="filter-icon"></div>
        </div>
        <ul id="types">
        <template id="typeItems" is="dom-repeat" items="{{types}}" as="type">
            <li on-click="_onTypeSelected">{{type}}</li>
        </template>
        </ul>
    </template>
    <script>
        var ComponentTypeSelectorControl = Polymer({
            is: "x-component-type-inspector",
            hostAttributes: {
                tabindex: -1
            },
            properties: {
                types: {
                    type: Array,
                    value: [ ]
                }
            },
            listeners: {
                'keydown': '_onContainerKeyDown',
                'blur': '_onContainerBlur',
                'filter.blur': '_onContainerBlur',
                'filter.input': '_onFilterInput'
            },
            /**
             * Constructor
             * @param {Array<String>} componentTypes
             */
            factoryImpl: function(componentTypes) {
                this._rawTypes = componentTypes || [ ];

                this.set( 'types', this._rawTypes );
            },
            created: function() {
                this._selectedIndex = -1;
            },
            attached: function() {
                this.$.filter.focus( );
            },

            show: function(x, y) {
                this.style.left = x +'px';
                this.style.top = y +'px';

                setTimeout( function() {
                    var bounds = this.getBoundingClientRect( );

                    // fit inside window
                    if (bounds.bottom > window.innerHeight)
                        this.style.top = (window.innerHeight - bounds.height) + 'px';

                    this.classList.add( 'shown' );
                }.bind( this ), 0 );
            },
            close: function() {
                var self = this;

                // already closing
                if (this.classList.contains( 'closing' ))
                    return;

                this.classList.add( 'closing' );

                setTimeout( function() {
                    self.parentNode.removeChild( self );
                }, 175 );
            },

            _onContainerKeyDown: function(e) {
                switch (e.keyCode) {
                    // up
                    case 38:
                        this._selectedIndex =
                            Math.max( 0, this._selectedIndex - 1 );

                        this._onSelectedIndexChanged( );
                        break;
                    // down
                    case 40:
                        this._selectedIndex =
                            Math.min( this.get( 'types' ).length - 1, this._selectedIndex + 1 );

                        this._onSelectedIndexChanged( );
                        break;
                    // return
                    case 13:
                        this._selectSelectedType( );
                        break;
                }
            },
            _onContainerBlur: function(e) {
                // needs to be bound to a timeout so document.activeElement has time to update
                setTimeout( function() {
                    var focus = document.activeElement;

                    if (!(focus === this || this.contains( focus )))
                        this.close( );
                }.bind( this ), 0 );
            },
            _onFilterInput: function(e) {
                var output;

                var value = this.$.filter.value.toLowerCase( );

                if (value.length) {
                    output = this._rawTypes
                    // filter types that don't contain this value
                    .filter( function(type) {
                        return type.toLowerCase( ).indexOf( value ) != -1;
                    } )
                    // sort based on where the name exists
                    .sort( function(a, b) {
                        return a.toLowerCase( ).indexOf( value ) -
                               b.toLowerCase( ).indexOf( value );
                    } );
                } else {
                    output = this._rawTypes;
                }

                this._selectedIndex = 0;

                this.set( 'types', output );

                this._onSelectedIndexChanged( );
            },
            _onTypeSelected: function(e) {
                this._notifySelected( e.model.type );
            },

            _onSelectedIndexChanged: function() {
                var lastSelected = this.$.types.querySelector( 'li.selected' );
                var items = this.$.types.querySelectorAll( 'li' );

                if (lastSelected)
                    lastSelected.classList.remove( 'selected' );

                var item = items[ this._selectedIndex ];

                if (item) {
                    item.classList.add( 'selected' );

                    item.scrollIntoViewIfNeeded( );
                }
            },

            _selectSelectedType: function() {
                var selected = this.$.types.querySelector( 'li.selected' );

                if (!selected)
                    return;

                this._notifySelected( this.$.typeItems.modelForElement( selected ).type );
            },
            _notifySelected: function(type) {
                this.fire( 'type-selected', {
                    type: type
                } );

                this.close( );
            }
        });
    </script>
</dom-module>